#include "line_sensor.h"

#include <config.h>
#include <adc.h>

LineSensor line_sensor;





LineSensor::LineSensor()
{

}

LineSensor::~LineSensor()
{

}


int LineSensor::init()
{
  int init_res = 0;

  sensor_led = 0;
  timer.delay_ms(100);

  adc_init();
  timer.delay_ms(100);

  for (unsigned int i = 0; i < LINE_SENSOR_COUNT; i++)
    adc_calibration[i] = adc_read(i);

  sensor_led = 1;
  timer.delay_ms(100);

  for (unsigned int i = 0; i < LINE_SENSOR_COUNT; i++)
    adc_calibration_k[i] =  adc_read(i) - adc_calibration[i];


  for (unsigned int i = 0; i < LINE_SENSOR_COUNT; i++)
    adc_result[i] = 0;



  for (unsigned int i = 0; i < LINE_SENSOR_COUNT; i++)
    weights[i] = config.line_sensor_config.weights[i];

  threshold = config.line_sensor_config.threshold;

  new_data_flag = false;

  return init_res;
}

bool LineSensor::new_data()
{
  bool res = false;
  if (new_data_flag)
  {
    res = true;
    new_data_flag = false;
  }

  return res;
}

int LineSensor::get_max()
{
  return 256;
}

int LineSensor::get_min()
{
  return -get_max();
}

void LineSensor::on()
{
  sensor_led = 1;
}

void LineSensor::off()
{
  sensor_led = 0;
}

void LineSensor::read()
{
  for (unsigned int i = 0; i < LINE_SENSOR_COUNT; i++)
  {
    adc_result[i] = 1000-((adc_read(i) - adc_calibration[i])*1000)/adc_calibration_k[i];
    if (adc_result[i] < 0)
      adc_result[i] = 0;
  }

  tmp_result.on_line = false;

  unsigned int max_i = 0;
  for (unsigned int i = 0; i < LINE_SENSOR_COUNT; i++)
    if (adc_result[i] > adc_result[max_i])
        max_i = i;

  if (adc_result[max_i] > threshold)
    tmp_result.on_line = true;

  if (tmp_result.on_line)
  {
    tmp_result.line_type = 1;

    tmp_result.left_line_position = integrate(max_i);
    //tmp_result.left_line_position = integrate_simson(max_i);

    tmp_result.right_line_position = tmp_result.left_line_position;
  }

  result = tmp_result;
  new_data_flag = true;
}


int LineSensor::integrate(unsigned int max_i)
{
  int middle = weights[max_i]*adc_result[max_i];
  int sum = adc_result[max_i];

  int int_result = middle;

  if (max_i > 0)
  {
    int_result+= weights[max_i-1]*adc_result[max_i-1];
    sum+= adc_result[max_i-1];
  }
  else
  {
    int_result+= middle;
    sum+= adc_result[max_i];
  }

  if (max_i < (LINE_SENSOR_COUNT-1))
  {
    int_result+= weights[max_i+1]*adc_result[max_i+1];
    sum+= adc_result[max_i+1];
  }
  else
  {
    int_result+= middle;
    sum+= adc_result[max_i];
  }

  int_result = int_result/sum;

  return int_result;
}



int LineSensor::integrate_simson(unsigned int first_max_i)
{
  unsigned int second_max_i=0;
  int int_result=0;


  if(first_max_i!=0 && first_max_i!=7)
  {
    if (adc_result[first_max_i-1]<adc_result[first_max_i+1])
    {
      /*secound max value is left:*/
      second_max_i=first_max_i+1;
    }
    else if(adc_result[first_max_i-1]>adc_result[first_max_i+1])
    {
      /*secound max value is left*/
      second_max_i=first_max_i-1;
    }
    else
    {
      /*values are the same: thoose simply max_i-1 as second max value: */
      second_max_i=first_max_i-1;
    }
  }
  else
  {
    /*edge checking:*/
    if(first_max_i==0)
    {
      second_max_i=0;
    }
    else
    {
      second_max_i=7;
    }
  }

  /*Now we know the socond index: Do the calculation:*/
  switch(first_max_i)
  {
    case 0:
    {
      int_result=integrate_partitial(0,0,0,1);
      break;
    }
    case 1:
    {
      if(first_max_i<second_max_i)
      {
        int_result=integrate_partitial(0,1,2,3);
      }
      else
      {
        int_result=integrate_partitial(0,0,1,2);
      }
      break;
    }
    case 2:
    case 3:
    case 4:
    case 5:
    {
      if(first_max_i<second_max_i)
      {
        int_result=integrate_partitial(first_max_i-1, first_max_i, second_max_i, second_max_i+1);
      }
      else
      {
        int_result=integrate_partitial(second_max_i-1, second_max_i, first_max_i, first_max_i+1);
      }
      break;
    }
    case 6:
    {
      if(first_max_i<second_max_i)
      {
        int_result=integrate_partitial(5,6,7,7);
      }
      else
      {
        int_result=integrate_partitial(4,5,6,7);
      }
      break;
    }
    case 7:
    {
      int_result=integrate_partitial(6,7,7,7);
      break;
    }
  }
  /*return result*/
  return int_result;
}


int LineSensor::integrate_partitial(unsigned int pos0, unsigned int pos1,
                                     unsigned int pos2, unsigned int pos3)
{
  int part_result = 0;
  int sum = 0;

  part_result += 1*weights[pos0]*adc_result[pos0];
  part_result += 3*weights[pos1]*adc_result[pos1];
  part_result += 3*weights[pos2]*adc_result[pos2];
  part_result += 1*weights[pos3]*adc_result[pos3];

  sum += 1*adc_result[pos0];
  sum += 3*adc_result[pos1];
  sum += 3*adc_result[pos2];
  sum += 1*adc_result[pos3];

  return part_result/sum;
}
